import { VerticalBox, HorizontalBox } from "std-widgets.slint";
global ImageIds {
  in-out property <[image]> images_by_index: [
      @image-url("icons/tile008.png"),
      @image-url("icons/tile011.png"),
      @image-url("icons/tile017.png"),
      @image-url("icons/tile148.png"),
      @image-url("icons/tile031.png"), // 4 is none found
      @image-url("icons/tile035.png"), 
      @image-url("icons/tile165.png"), //weird doggo
      @image-url("icons/tile032.png"), //closed chest
      @image-url("icons/tile033.png"), //opened chest
      @image-url("icons/tile025.png"), //closed door
      @image-url("icons/tile020.png"), //opened "door"
  ];
}

export enum InputCommand { 
  Direction, Position, Wait,
 } 

struct TileGraphics {
  image_ids: [int],
}

component MapTile inherits Rectangle {
  callback clicked();

  in property <[int]> image_ids;

  in property <int> grid_x;
  in property <int> grid_y;

  in property <length> size;

  x: grid_x * size;
  y: grid_y * size;
  width: size;
  height: size;

  for id[i] in image_ids : Image {
      source: ImageIds.images_by_index[id];
      width: parent.width;
      height: parent.height;
  }

  TouchArea {
      clicked => {
          root.clicked();
      }
  }
}

component GameMap inherits Rectangle {
  in property <int> grid_width;
  in property <int> grid_height;
  in property <length> tile-size;

  in property <[TileGraphics]> memory_tiles;

  callback received_input(InputCommand, int, int);

  x: 0;
  y: 0;
  height: grid_height * tile-size;
  width: grid_width * tile-size;

  for tile[i] in memory_tiles : MapTile {
    grid_x: mod(i, grid_width);
    grid_y: floor(i / grid_width);
    size: tile_size;

    image_ids: tile.image_ids;

    clicked => {
      root.received-input(InputCommand.Position, self.grid_x, self.grid_y);
    }
  }
}

component TextLog inherits Rectangle {

  background: #B8CD55;
  border-color: #69903B;

  border-width: 4px;

  text_box := Text {
    x: parent.border-width + 2px; 
    y: parent.border-width + 2px;
    height: parent.height - (parent.border-width + 2px) * 2;
    horizontal-alignment: left;
    vertical-alignment: top;
  }

  public function display_message(msg: string) {
    text-box.text = msg + "\n" + text-box.text;
  }
}

export component MainWindow inherits Window {
  background: #204631;

  width: grid-width * tile-size * 1.25;
  height: grid-height * tile-size * 1.25;

  callback received_input(InputCommand, int, int);

  in property <length> tile_size;
  in property <int> grid_width;
  in property <int> grid_height;

  in property <[TileGraphics]> memory_tiles;

  HorizontalBox {
    VerticalBox {
      padding: 0;
      GameMap { 
        tile-size: root.tile_size;
        grid_height: root.grid_height;
        grid_width: root.grid_width;
    
        memory_tiles: root.memory_tiles;
    
        received_input(command, x, y,) => {
          root.received_input(command, x, y);
        }
      }
    
      message_log := TextLog {}
    }
  }

  keyboard_handler := FocusScope {
    key-pressed(event) => {
      if (event.text == "w") {

        received-input(InputCommand.Direction, 0, -1);

      } else if (event.text == "a") {

        received-input(InputCommand.Direction, -1, 0);

      } else if (event.text == "s") {

        received-input(InputCommand.Direction, 0, 1);

      } else if (event.text == "d") {

        received-input(InputCommand.Direction, 1, 0);
      } else if (event.text == " ") {

        received-input(InputCommand.Wait, 0, 0);
      }
      accept
    }
  }

  public function display_message(msg: string) {
    message-log.display_message(msg);
  }
}
